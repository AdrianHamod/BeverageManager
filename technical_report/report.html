<!doctype html>
  <head>
    <style type="text/css">
      body {
        width: 21cm;
        height: 29.7cm;
        margin: 30mm 45mm 30mm 45mm; 
      } 
    </style>
    <meta charset="utf-8">
    <title>Beverage Manager technical report</title>
  </head>

  <article>
    <header>
      <h1>Beverage Manager technical report</h1>
      <div role="contentinfo">
        <section typeof="sa:AuthorsList">
          <h2>Contributors</h2>
          <ul>
            <li typeof="sa:ContributorRole" property="schema:author">
              <span typeof="schema:Person">
                <meta property="schema:givenName" content="Adrian">
                <meta property="schema:familyName" content="Hamod">
                <span property="schema:name">Adrian Hamod</span>
              </span>
              <ul>
                <li property="schema:roleContactPoint" typeof="schema:ContactPoint">
                  <a href="mailto:adrianhamod@gmail.com" property="schema:email"> adrianhamod@gmail.com
                  </a>
                </li>
              </ul>
            </li>
            <li typeof="sa:ContributorRole" property="schema:author">
              <span typeof="schema:Person">
                <meta property="schema:givenName" content="Dorian">
                <meta property="schema:additionalName" content="Gheorghe">
                <meta property="schema:familyName" content="Olărescu">
                <span property="schema:name">Dorian Olărescu</span>
              </span>
              <ul>
                <li property="schema:roleContactPoint" typeof="schema:ContactPoint">
                  <a href="mailto:dorian.olarescu@gmail.com" property="schema:email"> dorian.olarescu@gmail.com
                  </a>
                </li>
              </ul>
            </li>
          </ul>
        </section>
        <section>
          <h2>License and copyright</h2>
          <h3>
            <a href="https://creativecommons.org/licenses/by/4.0/" property="schema:license" typeof="CreativeWork">License</a>
            <h3>
          <div property="schema:copyrightYear"></div>
          <h3>Copyright</h3>
          <ul>
            <li property="schema:copyrightYear">2021</li>
            <li property="schema:copyrightHolder" typeof="schema:Organization">
              Facultatea de Informatică - Universitatea Alexandru Ioan Cuza
            </li>
          </ul>
        </section>
        <section typeof="sa:Abstract">
          <h2>Abstract</h2>
          This report details the technical aspects of building a web application
          around an ontological model describing the most common non-alcoholic beverages.
          The application described is statefull by design allowing users interacting
          with it to express preferences towards beverages. The mentioned preferences are
          modelled as a knowledge graph whereas the beverage resources are be modelled
          to include speciffic metadata (e.g.: category, price, ingredients etc.). In terms of features the application should also support browsing, filtering and even
          suggestions or correlations.
          The report show cases topics such as internal data structures, linked data principles, technologies used, cost of infrastructure, SLAs. For convinience, in the following sections we will reffer to the application as BEM - abvreviation for Beverage Manager, title of the project and application.
        </section>
        <section>
          <h2>1.0 BEM overview</h2>
          <section>
            <h3>1.1 Service overview</h3>
            The BEM service handles requests over an http connection. Over this connection authenticated clients can view queried resources rendered in html format. The frontend service handles delivery of static assets (html, css, js) and forwarding the queries to the query backend service. The backend service exposes and API for retrieving json representations of interlinked resources in RDF format. The API can also be made available for programmatic access or unauthenticated access as long as it accesses immutable resources describing non-user data (beverages excepting user preferences). Beverage related resources can be accessed via the /beverage/{resource} path where {resource} is a path parameter indicating the name of the resource. User preferences are available through the /profile/{user} route where {user} is a path parameter indicating the name of the user. The backend service queries the internal RDF storage to retrieve data and It can also be extended to run SPARQL queries on public sets of data such as DBPedia in order to merge additional metadata and link to external sources of data. RDF4J supports queries on remote SPARKQL endpoints such as DBPedia through the SPARKQLRepository API https://rdf4j.org/documentation/programming/setup/#accessing-a-sparql-endpoint
          </section>
          <section>
            <h3>1.2 Internal data representation</h3>
            The service internal model representation of data and resources is divided into 2 categories. As mentioned before accessing RDF data stores is done through the RDF4J Repository API. This enables us to work directly with the RDF4J Model API which provides class containers for the abstract RDF concepts. Resources are defined as IRI objects, literals are modeled as Literal objects, Statement objects abstract the concepts of subject, predicate and object through the use of IRIs and lastly blank nodes are represented through BNode object or null values. This model classes are used as entity objects when communicating with a data store such as DBPedia or our own ontology storage.
            When serving response the http requests the body of the response will contain a JSON-ld representation of the data.
          </section>
          <section>
            <h3>1.3 Internal storage</h3>
            For our internal ontology storage, we use a dedicated ElasticSearch instance since the Repository API offers a direct integration with it. Storing the data on a separate instance, as opposed to a in memory storage enables us to future proof for extensions such as database replication if there are concerns regarding availability or durability. One advantage of an in-memory storage is the fast access to data. Even so, the data retrievals from a remote server can be improved through caching solutions such as Redis if there are concerns in this sense. 
          </section>
          <section>
            <h3>1.4 Linked data principles</h3>
            We can outline several ideas mentioned above that describe the linked data feature of the application. Stored data is available on the web through the use of an HTTP connection. The ontology resources are described through unique URIs. The internal data is modelled in RDF format using the RDF4J API and the output is in JSON-LD representation. Outputted resources include links to other internal resources to which they describe relations. This linking is done through metadata links to those resources. This linking can be further improved through querying/merging external data available in other public stores such as DBPedia
          </section>
        </section>
        <section>
          <h2>2.0 Technologies used</h2>
          <section>
            <h3>2.1 Design and architecture</h3>
            A general architecture of the application and preliminary design considerations
            are available in the <a href="https://github.com/AdrianHamod/BeverageManager/tree/main/architecture">project repository</a>. This includes a diagram describing the service oriented architecture, preliminary UML representation of the backend service, OpenAPI specification of the public APIs exposed and descriptions of the application flow, query service and end client use cases. 
          </section>
          <section>
            <h3>2.2 Cloud services</h3>
            In order to orchestrate, deploy and ease the resource management several AWS services are used. 
            <section>
              <h4>2.2.1 API Gateway</h4>
              API Gateway is a service for managing API routing at service level as opposed to how popular web frameworks manage API routing at application domain level. What this means is requests are handled by central unit which resolves the service appropirate to delegate the request to. This is particularly useful in service oriented architectures where microservices are standalone applications and require an orchestration logic for the application flow to be implemented.
              API Gateway, being the application entry point, can conveniently handle authorization. We opt for using a 3rd party JWT authorizer which we directly integrate with API Gateway. Thus, once authenticated using the application internal logic, we can delegate authorization to API Gateway and authorize requests based on a speciffic header value.
              Lastly, we use API Gateway to manage throttling. Managing thortling at service level and delegating it to a trusted 3rd party such as AWS puts aside the operational burden of using intercepetor classes at the framework level with a proprietary implementation which must be maintained and tested.
            </section>
            <section>
              <h4>2.2.2 AWS EC2</h4>
              The second service in the service flow is a load balancer. Besides being a hosting service, AWS EC2 also provides neat integrations with said hosts such as load balancing, scaling groups, AMI market etc. In order to offload requests of our microservices an Application Load Balancer is used. 
              A first version of the application also considers self managing and deploying the ElasticSearch storage to an EC2 instance. 
            </section>
            <section>
              <h4>2.2.3 Elastic Container Service</h4>
              The mentioned load balancer front faces an ECS cluster. Amazon ECS is a fully managed container orchestration service with the purpose of easing deployment, service and resources management and scaling. What makes deployments easier is the fact that the ECS cluster is a hybrid enironment in regards to the runtimes and types of applications deployed. Elastic container registry is a service like feature integrated with ECS with the purpose of centralizing docker images used in deployment. We use ECS to deploy the frontend service, the authentication service and the query backend service in sepparate containers. ECS allows us to customize the host resources of each service, which helps with optimizing resource allocation. This also means that each type of service is scaled individually with respect to each container traffic load and each custom setting configured prior to deployment. 
              In addition to the scaling feature, Amazon also provides it's own on demand serverless containers to use with ECS. ECS with Fargate is the managed AWS alternative to using Kubernetes. The main advantage for us in using Fargate is that there are no upfront expenses since it follows the pay for only what you use paradigm. 
            </section>   
            <section>
              <h4>2.2.4 Amazon Relational Database Service</h4>
              Amazon RDS, specifically their in house built engine Aurora is a high performance serverless SQL database. The main role of the database is to store user data, including hashed credentials and profile data. The advantages of using Amazon RDS include high performance and scalability while still paying for only what you are using, fully delegation of management and integrations with AWS ecosystem from which main benefits is the ease of securing the database through VPCs and encrpytion services such as AWS KMS. 
            </section>
          </section>
        </section>
      </div>
    </header>
  </article> 
</html>
